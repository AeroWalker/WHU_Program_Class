//----------------------------------------------------------------------------
//  This file is automatically generated, do not modify.      
//----------------------------------------------------------------------------



using System;
using System.Runtime.InteropServices;
using Emgu.CV;
using Emgu.CV.Structure;
using Emgu.Util;

namespace Emgu.CV
{
   public static partial class CvInvoke
   {

     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern int cveBackgroundSubtractorMOG2GetHistory(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorMOG2SetHistory(
        IntPtr obj,  
        int val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     [return: MarshalAs(CvInvoke.BoolMarshalType)]
     internal static extern bool cveBackgroundSubtractorMOG2GetDetectShadows(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorMOG2SetDetectShadows(
        IntPtr obj, 
        [MarshalAs(CvInvoke.BoolMarshalType)] 
        bool val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern int cveBackgroundSubtractorMOG2GetShadowValue(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorMOG2SetShadowValue(
        IntPtr obj,  
        int val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern double cveBackgroundSubtractorMOG2GetShadowThreshold(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorMOG2SetShadowThreshold(
        IntPtr obj,  
        double val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern int cveBackgroundSubtractorMOG2GetNMixtures(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorMOG2SetNMixtures(
        IntPtr obj,  
        int val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern double cveBackgroundSubtractorMOG2GetBackgroundRatio(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorMOG2SetBackgroundRatio(
        IntPtr obj,  
        double val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern double cveBackgroundSubtractorMOG2GetVarThreshold(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorMOG2SetVarThreshold(
        IntPtr obj,  
        double val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern double cveBackgroundSubtractorMOG2GetVarThresholdGen(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorMOG2SetVarThresholdGen(
        IntPtr obj,  
        double val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern double cveBackgroundSubtractorMOG2GetVarInit(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorMOG2SetVarInit(
        IntPtr obj,  
        double val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern double cveBackgroundSubtractorMOG2GetVarMin(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorMOG2SetVarMin(
        IntPtr obj,  
        double val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern double cveBackgroundSubtractorMOG2GetVarMax(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorMOG2SetVarMax(
        IntPtr obj,  
        double val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern double cveBackgroundSubtractorMOG2GetComplexityReductionThreshold(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorMOG2SetComplexityReductionThreshold(
        IntPtr obj,  
        double val);
     
   }

   public partial class BackgroundSubtractorMOG2
   {

     /// <summary>
     /// The number of last frames that affect the background model
     /// </summary>
     public int History
     {
        get { return CvInvoke.cveBackgroundSubtractorMOG2GetHistory(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorMOG2SetHistory(_ptr, value); }
     }
     
     /// <summary>
     /// If true, the algorithm detects shadows and marks them.
     /// </summary>
     public bool DetectShadows
     {
        get { return CvInvoke.cveBackgroundSubtractorMOG2GetDetectShadows(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorMOG2SetDetectShadows(_ptr, value); }
     }
     
     /// <summary>
     /// Shadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0 in the mask always means background, 255 means foreground.
     /// </summary>
     public int ShadowValue
     {
        get { return CvInvoke.cveBackgroundSubtractorMOG2GetShadowValue(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorMOG2SetShadowValue(_ptr, value); }
     }
     
     /// <summary>
     /// A shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in the paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel is more than twice darker then it is not shadow.
     /// </summary>
     public double ShadowThreshold
     {
        get { return CvInvoke.cveBackgroundSubtractorMOG2GetShadowThreshold(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorMOG2SetShadowThreshold(_ptr, value); }
     }
     
     /// <summary>
     /// The number of gaussian components in the background model
     /// </summary>
     public int NMixtures
     {
        get { return CvInvoke.cveBackgroundSubtractorMOG2GetNMixtures(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorMOG2SetNMixtures(_ptr, value); }
     }
     
     /// <summary>
     /// If a foreground pixel keeps semi-constant value for about backgroundRatio * history frames, it's considered background and added to the model as a center of a new component. It corresponds to TB parameter in the paper.
     /// </summary>
     public double BackgroundRatio
     {
        get { return CvInvoke.cveBackgroundSubtractorMOG2GetBackgroundRatio(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorMOG2SetBackgroundRatio(_ptr, value); }
     }
     
     /// <summary>
     /// The main threshold on the squared Mahalanobis distance to decide if the sample is well described by the background model or not. Related to Cthr from the paper.
     /// </summary>
     public double VarThreshold
     {
        get { return CvInvoke.cveBackgroundSubtractorMOG2GetVarThreshold(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorMOG2SetVarThreshold(_ptr, value); }
     }
     
     /// <summary>
     /// The variance threshold for the pixel-model match used for new mixture component generation. Threshold for the squared Mahalanobis distance that helps decide when a sample is close to the existing components (corresponds to Tg in the paper). If a pixel is not close to any component, it is considered foreground or added as a new component. 3 sigma =%gt
     /// </summary>
     public double VarThresholdGen
     {
        get { return CvInvoke.cveBackgroundSubtractorMOG2GetVarThresholdGen(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorMOG2SetVarThresholdGen(_ptr, value); }
     }
     
     /// <summary>
     /// Tg=3*3=9 is default. A smaller Tg value generates more components. A higher Tg value may result in a small number of components but they can grow too large.
     /// </summary>
     public double VarInit
     {
        get { return CvInvoke.cveBackgroundSubtractorMOG2GetVarInit(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorMOG2SetVarInit(_ptr, value); }
     }
     
     /// <summary>
     /// The initial variance of each gaussian component
     /// </summary>
     public double VarMin
     {
        get { return CvInvoke.cveBackgroundSubtractorMOG2GetVarMin(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorMOG2SetVarMin(_ptr, value); }
     }
     
     /// <summary>
     /// The minimum variance
     /// </summary>
     public double VarMax
     {
        get { return CvInvoke.cveBackgroundSubtractorMOG2GetVarMax(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorMOG2SetVarMax(_ptr, value); }
     }
     
     /// <summary>
     /// The maximum variance
     /// </summary>
     public double ComplexityReductionThreshold
     {
        get { return CvInvoke.cveBackgroundSubtractorMOG2GetComplexityReductionThreshold(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorMOG2SetComplexityReductionThreshold(_ptr, value); }
     }
     
   }
}
