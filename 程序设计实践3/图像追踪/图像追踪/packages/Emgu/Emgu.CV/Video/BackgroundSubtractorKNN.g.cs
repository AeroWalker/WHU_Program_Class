//----------------------------------------------------------------------------
//  This file is automatically generated, do not modify.      
//----------------------------------------------------------------------------



using System;
using System.Runtime.InteropServices;
using Emgu.CV;
using Emgu.CV.Structure;
using Emgu.Util;

namespace Emgu.CV
{
   public static partial class CvInvoke
   {

     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern int cveBackgroundSubtractorKNNGetHistory(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorKNNSetHistory(
        IntPtr obj,  
        int val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern int cveBackgroundSubtractorKNNGetNSamples(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorKNNSetNSamples(
        IntPtr obj,  
        int val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern double cveBackgroundSubtractorKNNGetDist2Threshold(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorKNNSetDist2Threshold(
        IntPtr obj,  
        double val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern int cveBackgroundSubtractorKNNGetKNNSamples(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorKNNSetKNNSamples(
        IntPtr obj,  
        int val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     [return: MarshalAs(CvInvoke.BoolMarshalType)]
     internal static extern bool cveBackgroundSubtractorKNNGetDetectShadows(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorKNNSetDetectShadows(
        IntPtr obj, 
        [MarshalAs(CvInvoke.BoolMarshalType)] 
        bool val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern int cveBackgroundSubtractorKNNGetShadowValue(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorKNNSetShadowValue(
        IntPtr obj,  
        int val);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern double cveBackgroundSubtractorKNNGetShadowThreshold(IntPtr obj);
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)]
     internal static extern void cveBackgroundSubtractorKNNSetShadowThreshold(
        IntPtr obj,  
        double val);
     
   }

   public partial class BackgroundSubtractorKNN
   {

     /// <summary>
     /// The number of last frames that affect the background model
     /// </summary>
     public int History
     {
        get { return CvInvoke.cveBackgroundSubtractorKNNGetHistory(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorKNNSetHistory(_ptr, value); }
     }
     
     /// <summary>
     /// The number of data samples in the background model
     /// </summary>
     public int NSamples
     {
        get { return CvInvoke.cveBackgroundSubtractorKNNGetNSamples(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorKNNSetNSamples(_ptr, value); }
     }
     
     /// <summary>
     /// The threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to a data sample.
     /// </summary>
     public double Dist2Threshold
     {
        get { return CvInvoke.cveBackgroundSubtractorKNNGetDist2Threshold(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorKNNSetDist2Threshold(_ptr, value); }
     }
     
     /// <summary>
     /// The number of neighbours, the k in the kNN. K is the number of samples that need to be within dist2Threshold in order to decide that pixel is matching the kNN background model.
     /// </summary>
     public int KNNSamples
     {
        get { return CvInvoke.cveBackgroundSubtractorKNNGetKNNSamples(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorKNNSetKNNSamples(_ptr, value); }
     }
     
     /// <summary>
     /// If true, the algorithm detects shadows and marks them.
     /// </summary>
     public bool DetectShadows
     {
        get { return CvInvoke.cveBackgroundSubtractorKNNGetDetectShadows(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorKNNSetDetectShadows(_ptr, value); }
     }
     
     /// <summary>
     /// Shadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0 in the mask always means background, 255 means foreground.
     /// </summary>
     public int ShadowValue
     {
        get { return CvInvoke.cveBackgroundSubtractorKNNGetShadowValue(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorKNNSetShadowValue(_ptr, value); }
     }
     
     /// <summary>
     /// A shadow is detected if pixel is a darker version of the background. The shadow threshold (Tau in the paper) is a threshold defining how much darker the shadow can be. Tau= 0.5 means that if a pixel is more than twice darker then it is not shadow.
     /// </summary>
     public double ShadowThreshold
     {
        get { return CvInvoke.cveBackgroundSubtractorKNNGetShadowThreshold(_ptr); } 
        set { CvInvoke.cveBackgroundSubtractorKNNSetShadowThreshold(_ptr, value); }
     }
     
   }
}
