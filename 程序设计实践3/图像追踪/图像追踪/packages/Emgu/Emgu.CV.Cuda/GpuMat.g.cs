//----------------------------------------------------------------------------
//  This file is automatically generated, do not modify.      
//----------------------------------------------------------------------------



using System;
using System.Runtime.InteropServices;
using Emgu.CV;
using Emgu.CV.Structure;
using Emgu.Util;

namespace Emgu.CV.Cuda
{
   public static partial class CudaInvoke
   {

     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     [return: MarshalAs(CvInvoke.BoolMarshalType)]
     internal static extern bool cveGpuMatIsContinuous(IntPtr obj);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern CvEnum.DepthType cveGpuMatDepth(IntPtr obj);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     [return: MarshalAs(CvInvoke.BoolMarshalType)]
     internal static extern bool cveGpuMatIsEmpty(IntPtr obj);
     
     [DllImport(CvInvoke.ExternLibrary, CallingConvention = CvInvoke.CvCallingConvention)] 
     internal static extern int cveGpuMatNumberOfChannels(IntPtr obj);
     
   }

   public partial class GpuMat
   {

     /// <summary>
     /// True if the data is continues
     /// </summary>
     public bool IsContinuous
     {
        get { return CudaInvoke.cveGpuMatIsContinuous(_ptr); } 
     }
     
     /// <summary>
     /// Depth type
     /// </summary>
     public CvEnum.DepthType Depth
     {
        get { return CudaInvoke.cveGpuMatDepth(_ptr); } 
     }
     
     /// <summary>
     /// True if the matrix is empty
     /// </summary>
     public bool IsEmpty
     {
        get { return CudaInvoke.cveGpuMatIsEmpty(_ptr); } 
     }
     
     /// <summary>
     /// Number of channels
     /// </summary>
     public int NumberOfChannels
     {
        get { return CudaInvoke.cveGpuMatNumberOfChannels(_ptr); } 
     }
     
   }
}
